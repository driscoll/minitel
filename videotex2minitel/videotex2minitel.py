"""

videotex2minitel.py

Utilities for dealing with
Minitel, CebraText, Videotex

Kevin Driscoll
Minitel Research Lab, USA
http://minitel.us

September 9, 2012

WHAT IS THIS?

CebraText is a videotex/teletex editor 
for Microsoft Windows. This program
converts CebraText files to Minitel 
format and outputs source code to 
paste into slideshow.ino for the 
Arduino.

THANK YOU

Thanks to the Microtel team for 
documenting and preserving CebraText:
http://projects.lektrolab.com/microtel/

CEBRATEXT VIDEOTEX REFERENCE 

cebra_modes_text = bytearray([ 
    b'\x00', # black
    b'\x01', # red
    b'\x02', # green
    b'\x03', # yellow
    b'\x04', # blue
    b'\x05', # violet
    b'\x06', # cyan
    b'\x07'  # white
])

cebra_modes_graphics = [
    b'\x10', # black
    b'\x11', # red
    b'\x12', # green
    b'\x13', # yellow
    b'\x14', # blue
    b'\x15', # violet
    b'\x16', # cyan
    b'\x17'  # white
]

# Numerals
numerals = [
    b'\x30',
    b'\x31',
    b'\x32',
    b'\x33',
    b'\x34',
    b'\x35',
    b'\x36',
    b'\x37',
    b'\x38',
    b'\x39'
]
 
"""

from glob import glob
import sys

# Special characters
CLRSCR = b'\x0c'
BELL = b'\x07'
# SPACE = b'\x20'
ESC = 27 # 0x1B
SPACE = 32 # 0x20

# Display modes
# VIDEOTEX = 14 # 0x0e
# TEXT = 15 # 0x0f
VIDEOTEX = 14 # 0xf
TEXT = 15 # 0xe

# Colors
# Ordered from darkest to lightest
FORE = {
	'noir' : [ESC, b'\x40'], # noir, black
	'bleu' : [ESC, b'\x44'], # bleu, blue
	'rouge' : [ESC, b'\x41'], # rouge, red
	'magenta' : [ESC, b'\x45'], # magenta (mauve, purple)
	'vert' : [ESC, b'\x42'], # vert, green
	'cyan' : [ESC, b'\x46'], # cyan (bleu clair)
	'jaune' : [ESC, b'\x43'], # jaune, yellow
	'blanc' : [ESC, b'\x47']  # blanc, white
}

FX = {
    'flash_start' : [ESC, b'\x48'], # flashing
    'flash_stop'  : [ESC, b'\x49']  # fixed
}

BACK = {
	'noir' : [ESC, b'\x50'], # noir, black
	'bleu' : [ESC, b'\x54'], # bleu, blue
	'rouge' : [ESC, b'\x51'], # rouge, red
	'magenta' : [ESC, b'\x55'], # magenta (mauve, purple)
	'vert' : [ESC, b'\x52'], # vert, green
	'cyan' : [ESC, b'\x56'], # cyan (bleu clair)
	'jaune' : [ESC, b'\x53'], # jaune, yellow
	'blanc' : [ESC, b'\x57']  # blanc, white
}

# Keys below are in dec
# Extra spaces are in there because of a quirk of CebraText
cebra_minitel_map = {
    0 : bytearray(FORE['noir'] + [TEXT, SPACE]), # '0x0' text black
    1 : bytearray(FORE['rouge'] + [TEXT, SPACE]), # '0x1' text red
    2 : bytearray(FORE['vert'] + [TEXT, SPACE]), # '0x2' text green
    3 : bytearray(FORE['jaune'] + [TEXT, SPACE]), # '0x3' text yellow
    4 : bytearray(FORE['bleu'] + [TEXT, SPACE]), # '0x4' text blue
    5 : bytearray(FORE['magenta'] + [TEXT, SPACE]), # '0x5' text violet
    6 : bytearray(FORE['cyan'] + [TEXT, SPACE]), # '0x6' text cyan
    7 : bytearray(FORE['blanc'] + [TEXT, SPACE]), # '0x7',  text white
    8 : bytearray(FX['flash_start']), 
    9 : bytearray(FX['flash_stop']), 
    16 : bytearray(FORE['noir'] + [VIDEOTEX, SPACE]), # '0x10' graphic black
    17 : bytearray(FORE['rouge'] + [VIDEOTEX, SPACE]), # '0x11' graphic red
    18 : bytearray(FORE['vert'] + [VIDEOTEX, SPACE]), # '0x12' graphic green
    19 : bytearray(FORE['jaune'] + [VIDEOTEX, SPACE]), # '0x13' graphic yellow
    20 : bytearray(FORE['bleu'] + [VIDEOTEX, SPACE]), # '0x14' graphic blue
    21 : bytearray(FORE['magenta'] + [VIDEOTEX, SPACE]), # '0x15' graphic violet
    22 : bytearray(FORE['cyan'] + [VIDEOTEX, SPACE]), # '0x16' graphic cyan
    23 : bytearray(FORE['blanc'] + [VIDEOTEX, SPACE]), # '0x17'  graphic white
    32 : bytearray([SPACE]) # '0x20' == ' '
}

def cebra2minitel(b):
    """Convert CebraText byte to one or more Minitel bytes
    Returns list of bytes
    """
    minitel = bytearray() 
    if b in cebra_minitel_map.keys(): 
        # Is it a special char?
        minitel.extend(cebra_minitel_map[b])

    elif ((b >= 33) and (b < 128)):
        # Is it a printable character?
        minitel.append(b)

    else:
        # skip
        # minitel.append(b)
        pass
    
    """
    For debugging purposes:
    print b,
    print ': ',
    print minitel
    """
    return minitel

def c_array(cebra, name = 'data', line_length = 20):
    """Construct C-style array of Minitel bytes from 
    a TTV file generated by CebraText
    Returns list of strings
    """
    bytes = []
    for b in cebra:
       bytes.extend(cebra2minitel(b))
    num_bytes = len(bytes)

    output = []
    line = 'const int {0}_length = {1};\n'.format(name, num_bytes);
    line += 'const char {0}[{0}_length] PROGMEM'.format(name, num_bytes)
    line += ' = {\n'
    output.append(line)

    line = ''
    for i in range((num_bytes-1)):
        try:
            line += hex(int(bytes[i]))
        except TypeError as e:
            print e
            print 'Failed on byte: ',
            print i
        line += ','
    
        if (not ((i+1) % line_length)):
            line += '\n'
            output.append(line)
            line = ''
    
    line += hex(bytes[-1])
    line += '\n};\n\n'
    output.append(line)

    line = 'void show_{0}'.format(name)
    line += '() {\n'
    line += '  serialprint7(CLRSCR);\n'
    line += '  serialprint7(VIDEOTEX);\n'
    line += '  for (int i = 0; i < {0}'.format(name)
    line += '_length; i++) {\n'
    line += '    byte b = pgm_read_byte_near({0}'.format(name)
    line += ' + i);\n'
    line += '    serialprint7(b);\n'
    line += '  }\n'
    line += '}\n\n'
    output.append(line)
    return output

if __name__=='__main__':

    for fn in glob(sys.argv[1]):
        ttvf = open(fn, 'rb')
        filename = fn.split('.')[0]
        # First 40 bytes are empty for the top row
        # Last 11 bytes don't matter for Minitel
        ttv = bytearray(ttvf.read())[40:-11]
        for line in c_array(ttv, name=filename):
            s = str(line)
            sys.stdout.write(s)
 
